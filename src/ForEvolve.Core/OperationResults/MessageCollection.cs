using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ForEvolve.OperationResults
{
    /// <summary>
    /// Represents a collection of <see cref="ForEvolve.OperationResults.IMessage" />.
    /// Implements the <see cref="System.Collections.Generic.IList{ForEvolve.OperationResults.IMessage}" />
    /// </summary>
    /// <seealso cref="System.Collections.Generic.IList{ForEvolve.OperationResults.IMessage}" />
    public class MessageCollection : IList<IMessage>
    {
        private readonly List<IMessage> _items = new List<IMessage>();

        /// <inheritdoc />
        public IMessage this[int index] { get => _items[index]; set => _items[index] = value; }

        /// <inheritdoc />
        public int Count => _items.Count;

        /// <inheritdoc />
        public bool IsReadOnly => ((IList<IMessage>)_items).IsReadOnly;

        /// <inheritdoc />
        public void Add(IMessage item)
        {
            _items.Add(item);
        }

        /// <inheritdoc />
        public void Clear()
        {
            _items.Clear();
        }

        /// <inheritdoc />
        public bool Contains(IMessage item)
        {
            return _items.Contains(item);
        }

        /// <inheritdoc />
        public void CopyTo(IMessage[] array, int arrayIndex)
        {
            _items.CopyTo(array, arrayIndex);
        }

        /// <inheritdoc />
        public IEnumerator<IMessage> GetEnumerator()
        {
            return ((IList<IMessage>)_items).GetEnumerator();
        }

        /// <inheritdoc />
        public int IndexOf(IMessage item)
        {
            return _items.IndexOf(item);
        }

        /// <inheritdoc />
        public void Insert(int index, IMessage item)
        {
            _items.Insert(index, item);
        }

        /// <inheritdoc />
        public bool Remove(IMessage item)
        {
            return _items.Remove(item);
        }

        /// <inheritdoc />
        public void RemoveAt(int index)
        {
            _items.RemoveAt(index);
        }

        /// <inheritdoc />
        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IList<IMessage>)_items).GetEnumerator();
        }

        /// <summary>
        /// Determines whether this instance contains error messages.
        /// </summary>
        /// <returns><c>true</c> if this instance contains error messages; otherwise, <c>false</c>.</returns>
        public virtual bool HasError()
        {
            return _items.Any(x => x.Severity == OperationMessageLevel.Error);
        }

        /// <summary>
        /// Determines whether this instance contains warning messages.
        /// </summary>
        /// <returns><c>true</c> if this instance contains warning messages; otherwise, <c>false</c>.</returns>
        public virtual bool HasWarning()
        {
            return _items.Any(x => x.Severity == OperationMessageLevel.Warning);
        }

        /// <summary>
        /// Determines whether this instance contains information messages.
        /// </summary>
        /// <returns><c>true</c> if this instance contains information messages; otherwise, <c>false</c>.</returns>
        public virtual bool HasInformation()
        {
            return _items.Any(x => x.Severity == OperationMessageLevel.Information);
        }
    }

    /// <summary>
    /// Represents an operation result containing optional messages, generated by the operation.
    /// </summary>
    public interface IOperationResult
    {
        /// <summary>
        /// Gets a value indicating whether the operation has succeeded.
        /// </summary>
        /// <value><c>true</c> if the operation has succeeded; otherwise, <c>false</c>.</value>
        bool Succeeded { get; }

        /// <summary>
        /// Gets the messages associated with the operation result.
        /// </summary>
        /// <value>The operation result messages.</value>
        MessageCollection Messages { get; }

        /// <summary>
        /// Determines whether the operation generated any messages.
        /// </summary>
        /// <returns><c>true</c> if the operation generated messages; otherwise, <c>false</c>.</returns>
        bool HasMessages();
    }

    /// <summary>
    /// Represents an operation result containing optional messages, generated by the operation.
    /// Implements the <see cref="ForEvolve.OperationResults.IOperationResult" />
    /// </summary>
    /// <seealso cref="ForEvolve.OperationResults.IOperationResult" />
    public class OperationResult : IOperationResult
    {
        /// <inheritdoc />
        public bool Succeeded => !Messages.HasError();

        /// <inheritdoc />
        public MessageCollection Messages { get; } = new MessageCollection();

        /// <inheritdoc />
        public bool HasMessages()
        {
            return Messages.Count > 0;
        }
    }

    /// <summary>
    /// Represents an operation result containing optional messages, generated by the operation, and an optional resulting object.
    /// Implements the <see cref="ForEvolve.OperationResults.OperationResult" />
    /// Implements the <see cref="ForEvolve.OperationResults.IOperationResult{TValue}" />
    /// </summary>
    /// <typeparam name="TValue">The type of the t value.</typeparam>
    /// <seealso cref="ForEvolve.OperationResults.OperationResult" />
    /// <seealso cref="ForEvolve.OperationResults.IOperationResult{TValue}" />
    public class OperationResult<TValue> : OperationResult, IOperationResult<TValue>
    {
        /// <inheritdoc />
        public TValue Value { get; set; }

        /// <inheritdoc />
        public bool HasValue()
        {
            return Value != null;
        }
    }

    /// <summary>
    /// Represents an operation result containing optional messages, generated by the operation, and an optional resulting object.
    /// Implements the <see cref="ForEvolve.OperationResults.IOperationResult" />
    /// </summary>
    /// <typeparam name="TValue">The type of the t value.</typeparam>
    /// <seealso cref="ForEvolve.OperationResults.IOperationResult" />
    public interface IOperationResult<TValue> : IOperationResult
    {
        /// <summary>
        /// Gets the value attached by the operation.
        /// </summary>
        /// <value>The operation result's value.</value>
        TValue Value { get; }

        /// <summary>
        /// Determines whether the operation attached a value.
        /// </summary>
        /// <returns><c>true</c> if the operation attached a value; otherwise, <c>false</c>.</returns>
        bool HasValue();
    }

    /// <summary>
    /// Represents a generic operation result message.
    /// </summary>
    public interface IMessage
    {
        /// <summary>
        /// Gets the severity associated with the message.
        /// </summary>
        /// <value>The severity.</value>
        OperationMessageLevel Severity { get; }

        /// <summary>
        /// Gets the message details.
        /// </summary>
        /// <value>The details.</value>
        IDictionary<string, object> Details { get; }
    }

    /// <summary>
    /// Represents a generic operation result message.
    /// Implements the <see cref="ForEvolve.OperationResults.IMessage" />
    /// </summary>
    /// <seealso cref="ForEvolve.OperationResults.IMessage" />
    public class Message : IMessage
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Message"/> class.
        /// </summary>
        /// <param name="severity">The severity.</param>
        public Message(OperationMessageLevel severity)
            : this(severity, new Dictionary<string, object>()) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Message"/> class.
        /// </summary>
        /// <param name="severity">The severity.</param>
        /// <param name="details">The details.</param>
        /// <exception cref="ArgumentNullException">details</exception>
        public Message(OperationMessageLevel severity, IDictionary<string, object> details)
        {
            Severity = severity;
            Details = details ?? throw new ArgumentNullException(nameof(details));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Message"/> class.
        /// </summary>
        /// <param name="severity">The message severity.</param>
        /// <param name="details">The message details that will be loaded in the <see cref="System.Collections.Generic.IDictionary{string, object}"/>.</param>
        /// <param name="ignoreNull">if set to <c>true</c> null properties will be ignored (not added in the <see cref="System.Collections.Generic.IDictionary{string, object}"/>).</param>
        /// <exception cref="ArgumentNullException">details</exception>
        public Message(OperationMessageLevel severity, object details, bool ignoreNull = true)
            : this(severity)
        {
            if (details == null) { throw new ArgumentNullException(nameof(details)); }
            LoadDetails(details, ignoreNull);
        }

        private void LoadDetails(object details, bool ignoreNull)
        {
            var properties = TypeDescriptor.GetProperties(details);
            foreach (PropertyDescriptor property in properties)
            {
                var value = property.GetValue(details);
                if (!ignoreNull || value != null)
                {
                    Details.Add(property.Name, value);
                }
            }
        }

        /// <inheritdoc />
        public virtual OperationMessageLevel Severity { get; }

        /// <inheritdoc />
        public virtual IDictionary<string, object> Details { get; }
    }

    /// <summary>
    /// Represents the <see cref="ForEvolve.OperationResults.IMessage" /> severity level.
    /// </summary>
    public enum OperationMessageLevel
    {
        /// <summary>
        /// Messages that has no impact in the application flow.
        /// </summary>
        Information = 0,

        /// <summary>
        /// Messages that highlight an abnormal or unexpected event in the application flow, but do not otherwise cause the application execution to stop.
        /// </summary>
        Warning = 1,

        /// <summary>
        /// Messages that highlight when the current flow of execution is stopped due to a failure.
        /// These should indicate a failure in the current activity, not an application-wide failure.
        /// </summary>
        Error = 2,
    }
}
